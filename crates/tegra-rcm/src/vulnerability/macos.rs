use std::time::Duration;

use super::Vulnerability;
use crate::SwitchDevice;

impl Vulnerability for SwitchDevice {
    fn backend_name() -> &'static str {
        "macos"
    }

    /// very simple on MacOS, just need to execute a read control
    fn trigger(&self, length: usize) -> crate::Result<()> {
        const GET_STATUS: u8 = 0x0;
        const STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT: u8 = 0x82;

        let mut buf = vec![0u8; length];

        let read = self.device().read_control(
            STANDARD_REQUEST_DEVICE_TO_HOST_TO_ENDPOINT,
            GET_STATUS,
            0,
            0,
            &mut buf,
            Duration::from_secs(1),
        );

        // we expect a timeout, if we did not receive one we should error
        if let Err(e) = read {
            if e == rusb::Error::Timeout {
                return Ok(());
            } else {
                return Err(e.into())
            }
        }

        Err(crate::Error::RcmExpectedError)
    }

    fn supported(&self) -> bool {
        true
    }
}
